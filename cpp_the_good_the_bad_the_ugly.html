<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>C++, The Good, The Bad and The Ugly</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/simple.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/atom-one-light.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
				    <h1>C++, the good, the bad and the ugly</h1>
				</section>
				<section>
				    <h2>The Good Parts</h2>
				    <p>An evolution from (pre) C++98 to C++17</p>
				</section>
				<section>
					<h2>A classic C++ example in many text books</h2>
					<pre><code class="cpp" data-trim>
					double pi = 3.1415926;

					double get_area() {
						double area, radius = 1.5;
						area = pi * radius * radius;
						return area;
					}
					</code></pre>
				</section>
				<section>
					<section>
						<h2>Always <code>const</code></h2>
						<ul>
							<li><code>const</code> expresses your intention well</code>
							<li><code>const</code> hints the compiler to do more optimizations</code>
							<li><code>const</code> forces value to be initialized</code>
						</ul>

						<pre><code class="cpp" data-trim>
						double const pi = 3.1415926;

						double get_area() {
							double const radius = 1.5;
							double const area = pi * radius * radius;
							return area;
						}
						</code></pre>
						<a href="https://godbolt.org/z/99T8Up">code</a>

						<p class="fragment">What does <code>const</code> really mean?</p>
						<p class="fragment">What's your "intention"?</p>
					    </textarea>
					</section>
					<section>
						<h2>Value is good</h2>
						<p>It is isolated from the outside world</p>
						<pre><code class="cpp" data-trim>
						struct S;
						extern void foo(S s);
						</code></pre>

						<p class="fragment" data-fragment-index="2">Is this <code>const</code> an illusion?</p>
						<pre class="fragment" data-fragment-index="1"><code class="cpp" data-trim>
						struct S;
						extern void foo(S const&amp; s);
						</code></pre>
					</section>
					<section>
						<p><code>const&</code> as a parameter type is complicated</p>
						<p class="fragment"><code>const_cast</code> breaks constness</p>
						<p class="fragment">Without caution, it may introduce a nasty <strong>undefined behavior</strong></p>
					</section>
					<section>
						<pre><code class="cpp" data-trim>
						struct S { int i{}; };
						S s;
						void foo(S const&amp; cs) {
							const_cast&lt;S&amp;&gt;(cs).i = 3;
						}
						</code></pre>

						<p class="fragment" data-fragment-index="2"><strong>ALARM, ALARM, UNDEFINED BEHAVIOR ALARM</strong></p>
						<pre class="fragment" data-fragment-index="1"><code class="cpp" data-trim data-noescape>
						struct S { int i{}; };
						S <mark>const</mark> s;
						void foo(S const&amp; cs) {
							const_cast&lt;S&amp;&gt;(cs).i = 3;
						}
						</code></pre>
					</section>
					<section>
						<p>What's this <code>const</code> mean?</p>
						<pre><code class="cpp" data-trim>
						struct S {
							void foo() const;
							int i{};
						};
						</code></pre>
					</section>
					<section>
						<pre><code class="cpp" data-trim data-noescape>
						struct S {
							void foo() const {
								i = 3;
							}
							<span class="fragment">mutable </span>int i{};
						};
						</code></pre>
						<p class="fragment"><code>const</code> and <code>mutable</code>, what do they mean?</p>
					</section>
					<section>
						<p>C++98: <code>const</code> means either bitwise constness or logic constness</p>
						<p>C++98: <code>mutable</code> means just ignore this variable for constness check</p>
						<p class="fragment">C++11: <code>const</code> means either bitwise constness or no data race</p>
						<p class="fragment">C++11: <code>mutable</code> means this variable is free of data race</p>
					</section>
					<section>
						<pre><code class="cpp" data-trim>
						struct S {
							void foo() const {
								i = 3;
							}
							mutable std::atomic&lt;int&gt; i{};
						};
						</code></pre>
						<pre><code class="cpp" data-trim data-noescape>
						struct S {
							void foo() const {
								std::lock_guard lk{m};
								i += 3;
							}
							mutable int i{};
							mutable std::mutex m{};
						};
						</code></pre>
					</section>
					<section>
						<p>C++11 adds better support for <code>const_iterator</code>, and non-member functions <code>std::begin</code> and <code>std::end</code></p>
						<p class="fragment">...an oversight during standardization, ...failed to add <code>cbegin</code>, <code>cend</code>, <code>rbegin</code>, <code>crbegin</code>, and <code>crend</code>. -- Scott Meyers</p>
					</section>
				</section>
				<section>
					<h2>DRY (Don't Repeat Yourself)</h2>
					<ul>
						<li>Use predefined values</li>
					</ul>

					<pre><code class="cpp" data-trim>
					#include &lt;boost&sol;math&sol;constants&sol;constants.hpp&gt;

					double get_area() {
						using boost::math::double_constants::pi;
						double const radius = 1.5;
						double const area = pi * radius * radius;
						return area;
					}
					</code></pre>
				</section>
				<section>
					<section>
						<h2>compile time evaluation</h2>
						<ul>
							<li>Move the effort to compile time (sometimes)</li>
						</ul>

						<pre><code class="cpp" data-trim>
						#include &lt;boost&sol;math&sol;constants&sol;constants.hpp&gt;

						constexpr double get_area() {
							using boost::math::double_constants::pi;
							constexpr double const radius = 1.5;
							constexpr double const area = pi * radius * radius;
							return area;
						}
						</code></pre>
						<a href="https://godbolt.org/z/D5SCod">constexpr fib</a>/<a href="https://godbolt.org/z/9BQ8UT">constexpr new</a>
					</section>
					<section>
						<h2>This is C++, we got lots of options</h2>
						<pre><code class="cpp" data-trim>
						constexpr int fib(int n) {
							if (n == 1) return 1;
							if (n == 2) return 2;
							return fib(n-1) + fib(n-2);
						}
						</code></pre>
					</section>
					<section>
						<p>Meta programming<p>
						<pre><code class="cpp" data-trim>
						template &lt;auto v&gt;
						struct Fib {
							static constexpr auto val = Fib&lt;v-1&gt;::val + Fib&lt;v-2&gt;::val;
						};

						template &lt;&gt; struct Fib&lt;1&gt; { static constexpr auto val = 1; }
						template &lt;&gt; struct Fib&lt;2&gt; { static constexpr auto val = 2; }
						</code></pre>
						<a href="https://godbolt.org/z/4sWWS_">code</a>
					</section>
					<section>
						<p><code>struct</code> functor<p>
						<pre><code class="cpp" data-trim>
						#include &lt;utility&gt;
						#include &lt;iostream&gt;

						struct Fib {
							constexpr int operator()() noexcept {
								n1 = std::exchange(n0, n0+n1);
								return n1;
							}
							int n0{0};
							int n1{1};
						};
						</code></pre>
						<a href="https://godbolt.org/z/RRA3Z6">code</a>
					</section>
					<section>
						<p><code>lambda</code><p>
						<pre><code class="cpp" data-trim>
						#include &lt;utility&gt;
						#include &lt;iostream&gt;

						auto fib = [n0=0, n1=1]() mutable {
							n1 = std::exchange(n0, n0+n1);
							return n1;
						};
						</code></pre>
						<a href="https://godbolt.org/z/JW-k5v">code</a>
					</section>
				</section>
				<section>
					<h2>Tidy up</h2>
					<pre><code class="cpp" data-trim>
					#include &lt;boost&sol;math&sol;constants&sol;constants.hpp&gt;

					constexpr double get_area(double radius) {
						return boost::math::double_constants::pi * radius * radius;
					}
					</code></pre>
					<p class="fragment">What if we have different types?</p>
				</section>
				<section>
					<section>
						<h2>The Ultimate DRY - <code>template</code></h2>
						<ul>
							<li>Compiler <strong>always</strong> does all the heavy lifting at compile time</li>
							<li>Type safe</li>
							<li>Generates code as efficient as hand writting one</li>
						</ul>

						<pre><code class="cpp" data-trim>
						#include &lt;boost&sol;math&sol;constants&sol;constants.hpp&gt;

						template &lt;typename T&gt;
						constexpr T get_area(T radius) {
							return boost::math::double_constants::pi * radius * radius;
						}
						</code></pre>
						<p class="fragment">There is one bug might crush your program</p>
					</section>
					<section>
						<h2>The danger of having good coworkers</h2>
						<pre><code class="cpp" data-trim>
						#include &lt;string&gt;
						#include &lt;string_view&gt;

						std::string operator+(std::string_view a, std::string_view b) {
							return std::string{a} + std::string{b};
						}

						template &lt;typename T&gt;
						T add(T a, T b) { return a + b; }

						int main() {
							using namespace std::literals;
							auto c = add("hello"sv, "world"sv);
						}
						</code></pre>
						<a href="https://godbolt.org/z/v9332d">code</a>
					</section>
					<section>
						<p>Multiple ways to solve one problem</p>
						<pre><code class="cpp" data-trim>
						template &lt;typename T&gt;

						auto add(T a, T b) { return a + b; }
						</code></pre>
						<pre class="fragment"><code class="cpp" data-trim>
						template &lt;typename R, typename T&gt;

						R add(T a, T b) { return a + b; }
						</code></pre>
						<pre class="fragment"><code class="cpp" data-trim>
						template &lt;typename R, typename T&gt;

						std::decay_t&lt;T&gt; add(T a, T b) { return a + b; }
						</code></pre>
						<p class="fragment">And many others...</p>
					</section>
					<section>
						<pre><code class="cpp" data-trim>
						std::string const&amp; get_default(std::map&lt;std::string, std::string&gt; const&amp; settings,
								std::string const&amp; key, std::string const&amp; dflt) {
							if (auto p = settings.find(key); p != settings.end()) {
								return p-&gt;second;
							}
							return dflt;
						}
						</code></pre>
						<pre class="fragment"><code class="cpp" data-trim>
						auto&amp;v = get_default(m, k, "127.0.0.1");
						</code></pre>
						<pre class="fragment"><code class="cpp" data-trim>
						std::string get_default(std::map&lt;std::string, std::string&gt; const&amp; settings,
								std::string const&amp; key, std::string&amp;&amp; dflt) {
							if (auto p = settings.find(key); p != settings.end()) {
								return p-&gt;second;
							}
							return dflt;
						}
						</code></pre>
					</section>
				</section>
				<section>
					<h2>What's wrong with the <code>factory()</code> API</h2>
					<ul>
						<li class="fragment">Is it a pointer to a static?</li>
						<li class="fragment">Is it a pointer dynamically allocated?</li>
						<li class="fragment">Should I release it? If so, how?</li>
					</ul>

					<pre><code class="cpp" data-trim>
					struct S;

					extern S* factory();
					</code></pre>
				</section>
				<section>
					<section>
						<h2>Easy to Use, Hard to Misuse</h2>
						<ul>
							<li>Return ref when it is a static</li>
							<li>Return a smart pointer when it is dyn allocated</li>
							<li>Never use raw pointers, which likely to be a design flaw</li>
						</ul>

						<pre><code class="cpp" data-trim>
						struct S;
						std::shared_ptr&lt;S&gt; factory() {
							return std::shared_ptr&lt;S&gt;{};
						};
						</code></pre>
						<p class="fragment">What is the performance implication of accessing a static?</p>
					</section>
					<section>
						<h2>C++11 made a promise...</h2>
						<p class="fragment">initializing a static variable is thread safe.</p>
						<pre><code class="cpp" data-trim data-noescape>
						#include &lt;string&gt;

						class S {
						public:
							static std::string const&amp; instance() {
								static std::string const s = "hello";<span class="fragment"> // there is an invisible guard</span>
								return s;
							}
						};
						</code></pre>
						<a href="https://godbolt.org/z/N7yTzh">code</a>
					</section>
					<section>
						<p>A better version?</p>
						<pre><code class="cpp" data-trim>
						#include &lt;string&gt;

						class S {
						public:
							std::string const&amp; instance() {
								return ref_;
							}
						private:
							std::string const&amp; ref_ = instance_();
							static std::string const&amp; instance_() {
								static std::string const s= "hello";
								return s;
							}
						}
						</code></pre>
						<a href="https://godbolt.org/z/SF_Urx">code</a>
					</section>
				</section>
				<section>
					<h2>Always prefer <code>std::make_shared</code> over <code>std::shared_ptr</code></h2>
					
					<pre><code class="cpp" data-trim>
					struct S;
					auto factory() {
						return std::make_shared&lt;S&gt;{};
					};
					</code></pre>
					<p class="fragment">Is <code>std::shared_ptr</code> thread safe, why?</p>
				</section>
				<section>
					<section>
						<h2>Almost always prefer <code>std::unique_ptr</code> over <code>std::shared_ptr</code></h2>
						<ul>
							<li><code>std::unique_ptr</code> is as efficient as a raw pointer</li>
							<li>Unless you need share owership</li>
						</ul>
						<pre><code class="cpp" data-trim>
						struct S;
						auto factory() {
							return std::make_unique&lt;S&gt;{};
						};
						</code></pre>
						<p class="fragment">Fun fact: <code>std::make_unique</code> was missing in C++11, added in C++14</p>
						<p class="fragment">...this is mostly an oversight... -- Herb Sutter, 2011</p>
					</section>
					<section>
						<h2>Permutation is fun</h2>
						<pre><code class="cpp" data-trim>
						void foo(S s);
						void foo(S&amp;&amp; s);
						void foo(S&amp; s);
						void foo(S const&amp; s);
						void foo(S* s);
						void foo(S const* s);
						</code></pre>

						<pre><code class="cpp" data-trim>
						void foo(std::unique_ptr&lt;S&gt; s);
						void foo(std::unique_ptr&lt;S&gt;&amp;&amp; s);
						void foo(std::unique_ptr&lt;S&gt;&amp; s);
						void foo(std::unique_ptr&lt;S&gt; const&amp; s);
						void foo(std::unique_ptr&lt;S&gt;* s);
						void foo(std::unique_ptr&lt;S&gt; const* s);
						</code></pre>

						<pre><code class="cpp" data-trim>
						void foo(std::shared_ptr&lt;S&gt; s);
						void foo(std::shared_ptr&lt;S&gt;&amp;&amp; s);
						void foo(std::shared_ptr&lt;S&gt;&amp; s);
						void foo(std::shared_ptr&lt;S&gt; const&amp; s);
						void foo(std::shared_ptr&lt;S&gt;* s);
						void foo(std::shared_ptr&lt;S&gt; const* s);
						</code></pre>
						<p class="fragment">Do not forget we can have templated parameter</p>
					</section>
				</section>
				<section>
					<section>
						<h2>RAII (Resource Requisition Is Initialization)</h2>
						<ul>
							<li>No memory leak</li>
						</ul>

						<pre><code class="cpp" data-trim>
						struct S {
						    S() : data(new int) {}
						    ~S() { delete data; }
						    int* data{};
						};
						</code></pre>
						<p class="fragment">There is a bug</p>
					</section>
					<section>
						<p>Believe or not</p>
						<p class="fragment">Mostly...,</p>
						<p class="fragment">it is not your fault</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Passing By Value is gooood</h2>
						<ul>
							<li>Copy elision</li>
							<li>RVO (Return Value Optimization)</li>
						</ul>

						<pre><code class="cpp" data-trim>
						extern S foo();
						extern void bar(S);

						bar(foo());
						S s = foo();
						</code></pre>

						<p class="fragment">There is a bug with ALL compilers</p>
					</section>
					<section>
						<p>If you have the necessity to define a destructor...,</p>
						<p class="fragment">implies you have some resource to manage,</p>
						<p class="fragment">you should define your own copy/move special functions.</p>
						<p class="fragment">That's the rationale behind this standard rule,</p>
						<p class="fragment">that if a class has user defined destructor</p>
						<p class="fragment">the compiler must not generate copy/move ctor/assignment functions for this class.</p>
						<p class="fragment">However,</p>
						<p class="fragment">all mainstream compilers still generate copy ctor/assignment functions.</p>
					</section>
				</section>
				<section>
					<pre><code class="cpp" data-trim>
					std::vector&lt;int&gt; data;
					data.push_back(1);
					data.push_back(2);
					data.push_back(3);
					</code></pre>
				</section>
				<section>
					<section>
						<h2>List Initializer</h2>

						<pre><code class="cpp" data-trim>
						std::vector&lt;int&gt; data = {1, 2, 3, 4};
						</code></pre>

						<p class="fragment">Is list initializer the biggest failure in C++? -- guy on twitter</p>
					</section>
					<section>
						<pre><code class="cpp" data-trim data-noescape>
						int i = 3;<span class="fragment"> // int</span>
						auto i = 3;<span class="fragment"> // int</span>

						int i = {3};<span class="fragment"> // int</span>
						auto i = {3}<span class="fragment"> // std::initializer_list</span>

						int i{3};<span class="fragment"> // int</span>
						auto i{3};<span class="fragment"> // it's complicated</span>
						<span class="fragment">// with c++11 flag, before gcc5/clang4.8, it is std::initializer_list, otherwise, it is a int<span>
						auto i = (int){3};</span><span class="fragment"> // int</span>
						
						int i(3);<span class="fragment"> // int</span>
						int i();<span class="fragment"> // function declaration</span>
						int i{};<span class="fragment"> // int</span>
						</code></pre>
					</section>
				</section>
				<section>
					<h2>CTAD (Class Template Argument Deduction)</h2>

					<pre><code class="cpp" data-trim>
					std::vector data = {1, 2, 3, 4};
					</code></pre>

					<p class="fragment">What if the length of vector is predetermined?</p>
				</section>
				<section>
					<h2>Raw array?</h2>

					<pre><code class="cpp" data-trim>
					int data[] = {1, 2, 3, 4};
					</code></pre>

					<p class="fragment">We can do better</p>
				</section>
				<section>
					<h2><code>std::array</code></h2>

					<ul>
						<li><code>std::array</code> provides more functionalities than raw array</li>
						<li>No runtime overhead</li>
						<li>Using raw array in modern code should be considered as a design flaw</li>
					</ul>

					<pre><code class="cpp" data-trim>
					std::array data = {1, 2, 3, 4};
					</code></pre>
				</section>
				<section>
					<h2>What's wrong with this API?</h2>

					<pre><code class="cpp" data-trim>
					#include &lt;map&gt;

					int foo(std::map&lt;int, int&gt; const&amp; m) {
					    for (std::map&lt;int, int&gt;::const_iterator it=m.begin(); it!=m.end(); ++it)
					        if (it-&gt;first &gt; 3 + it-&gt;second)
					            return it-&gt;second;
					    return -1;
					}
					</code></pre>
				</section>
				<section>
					<h2>Be familiar with STL</h2>

					<pre><code class="cpp" data-trim>
					#include &lt;map&gt;

					std::optional&lt;int&gt; foo(std::map&lt;int, int&gt; const&amp; m) {
					    for (std::map&lt;int, int&gt;::const_iterator it=m.begin(); it!=m.end(); ++it)
					        if (it-&gt;first &gt; 3 + it-&gt;second)
					            return it-&gt;second;
					    return {};
					}
					</code></pre>

					<p class="fragment"><code>boost::outcome</code> is even better</p>
				</section>
				<section>
					<h2>(AAA) Almost always <code>auto</code> - Herb Sutter</h2>

					<pre><code class="cpp" data-trim>
					#include &lt;map&gt;

					std::optional&lt;int&gt; foo(std::map&lt;int, int&gt; const&amp; m) {
					    for (auto it=m.begin(); it!=m.end(); ++it)
					        if (it-&gt;first &gt; 3 + it-&gt;second)
					            return it-&gt;second;
					    return {};
					}
					</code></pre>
				</section>
				<section>
					<h2>Range-based for loops</h2>

					<pre><code class="cpp" data-trim>
					#include &lt;map&gt;

					std::optional&lt;int&gt; foo(std::map&lt;int, int&gt; const&amp; m) {
					    for (auto&amp; p : m)
					        if (p.first &gt; 3 + p.second)
					            return p.second;
					    return {};
					}
					</code></pre>
				</section>
				<section>
					<section>
						<h2>Structured binding</h2>

						<pre><code class="cpp" data-trim>
						#include &lt;map&gt;

						std::optional&lt;int&gt; foo(std::map&lt;int, int&gt; const&amp; m) {
							for (auto&amp; [key, value] : m)
								if (key &gt; 3 + value)
									return value;
							return {};
						}
						</code></pre>

						<p class="fragment">What is the performance implication of structured binding?</p>
					</section>
					<section>
						<pre><code class="cpp" data-trim>
						struct BigStruct;

						auto [k, v] = std::pair&lt;BigStruct, BigStruct&gt;{};
						</code></pre>

						<pre class="fragment"><code class="cpp" data-trim>
						std::pair&lt;BigStruct, BigStruct&gt; tmp = std::pair&lt;BigStruct, BigStruct&gt;{};
						alias k = tmp.first;
						alias v = tmp.second;
						</code></pre>
					</section>
					<section>
						<pre><code class="cpp" data-trim>
						struct BigStruct;

						auto&amp; [k, v] = std::pair&lt;BigStruct, BigStruct&gt;{};
						</code></pre>

						<pre class="fragment"><code class="cpp" data-trim>
						std::pair&lt;BigStruct, BigStruct&gt;&amp; tmp = std::pair&lt;BigStruct, BigStruct&gt;{};
						alias k = tmp.first;
						alias v = tmp.second;
						</code></pre>
					</section>
					<section>
						<p>Believe or not,</p>
						<p class="fragment">how to declare/initialize a variable,</p>
						<p class="fragment">how to declare/define signatures of a function,</p>
						<p class="fragment">how to declare/define a very basic class/struct,</p>
						<p class="fragment">after all these years, are still very hot topices in C++ community</p>
					</section>
					<section>
						<blockquote>
							<p>C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do, it blows your whole leg off</p>
							<p>-- Bjarne Stroustrup</p>
							<p class="fragment">There are only two kinds of languages: the ones people complain about and the ones nobody uses</p>
						</blockquote>
					</section>
					<section>
						<img data-src="img/caution_cpp.png"/>
					</section>
				</section>
				<section>
					<h2>No Raw <code>for</code> loops -- Sean Parent</h2>

					<ul>
						<li>Know your algorithms</li>
					</ul>

					<pre><code class="cpp" data-trim>
					#include &lt;map&gt;
					#include &lt;algorithm&gt;

					struct F {
						bool operator()(std::pair&lt;int, int&gt; p) {
							return p.first &gt; 3 + p.second;
						}
					};

					std::optional&lt;int&gt; foo(std::map&lt;int, int&gt; m) {
						if (auto it=std::find_if(cbegin(m), cend(m), F()); it!=m.end())
							return it-&gt;second;
						return {};
					}
					</code></pre>

					<p class="fragment">We can do better with <code>F</code></p>
				</section>
				<section>
					<ul>
						<li><code>final</code></li>
						<li><code>[[nodiscard]]</code></li>
						<li><code>noexcept</code></li>
					</ul>

					<pre><code class="cpp" data-trim>
					struct F final {
						[[nodiscard]] constexpr bool operator()(std::pair&lt;int, int&gt; p) const noexcept {
							return p.first &gt; 3 + p.second;
						}
					};
					</code></pre>

					<p class="fragment">What does a <code>const</code> member function imply?</p>
				</section>
				<section>
					<ul>
						<li>override</li>
					</ul>

					<pre><code class="cpp" data-trim>
					struct B {
						virtual void foo();
					};
					struct D : B {
						void foo() override;
					}
					</code></pre>

					<p class="fragment">Inheritance is the base class of all evil -- Sean Parent</p>
				</section>
				<section>
					I hope we have functions use <strong><code>constexpr</code></strong>, <strong><code>const</code></strong>, <strong><code>noexcept</code></strong> as default attributes
				</section>
				<section>
					<h2><code>lambda</code></h2>

					<ul>
						<li>By default, it is <code>const</code> and <code>noexcept</code></li>
						<li>Can be <code>constexpr</code> if it is needed</li>
					</ul>

					<pre><code class="cpp" data-trim>
						auto f = []() {};
					</code></pre>

					<pre class="fragment"><code class="cpp" data-trim>
					std::optional&lt;int&gt; foo(std::map&lt;int, int&gt; m) {
					if (auto it=std::find_if(cbegin(m), cend(m),
								[](std::pair&lt;int, int&gt; const&amp; p) { return p.first &gt; 3 + p.second; }; it!=m.end())
							return it-&gt;second;
						return {};
					}
					</code></pre>
				</section>
				<section>
					<h2>Generic <code>lambda</code></h2>

					<pre><code class="cpp" data-trim>
					std::optional&lt;int&gt; foo(std::map&lt;int, int&gt; m) {
					if (auto it=std::find_if(cbegin(m), cend(m),
								[](auto const&amp; p) { return p.first &gt; 3 + p.second; }; it!=m.end())
							return it-&gt;second;
						return {};
					}
					</code></pre>
				</section>
				<section>
					<h2>What's wrong with raw string literal</h2>

					<ul>
						<li>Either do not have size info</li>
						<li>Or like a raw array (it is), decays to pointer easily</li>
					</ul>

					<pre><code class="cpp" data-trim>
					char const* s1 = "hello";   // s1: char const*
					char const s2[] = "hello";  // s2: char const[6]
					</code></pre>
				</section>
				<section>
					<h2>How about <code>std::string</code></h2>
					<ul>
						<li><span class="fragment">It allocates</span><span class="fragment"> sometimes</span></li>
					</ul>

					<pre><code class="cpp" data-trim>
					std::string s1 = "hello";
					std::string s2 = "hello hello hello";
					std::string s3 = "very looooooooooooooooog string";
					</code></pre>
				</section>
				<section>
					<h2><code>std::string_view</code> comes to rescure</h2>
					<ul>
						<li>Almost identical API compare to <code>std::string</code></li>
						<li>No overhead compare to raw string literals</li>
					</ul>

					<pre><code class="cpp" data-trim>
					std::string_view s = "hello";
					</code></pre>

					<p class="fragment"><code>std::string_view</code> is merely a view!</p>
				</section>
				<section>
					<h2>How to write a <code>print</code></h2>
					<pre><code class="cpp" data-trim>
					struct S{};
					std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, S const&amp; s);

					print(3, "hi", 7.8);
					print(3, "hi", 7.8, std::string("aloha"));
					print(3, "hi", 7.8, std::string("aloha"), S{});
					</code></pre>
				</section>
				<section>
					<h2>Solution 1</h2>

					<pre><code class="cpp" data-trim>
					template &lt;typename T1, typename T2, typename T3&gt;
					void print(T1 const&amp; t1, T2 const&amp; t2, T3 const&amp; t3) {
						std::cout &lt;&lt; t1 &lt;&lt; ' ' &lt;&lt; t2 &lt;&lt; ' ' &lt;&lt; t3;
					}
					template &lt;typename T1, typename T2, typename T3, typename T4&gt;
					void print(T1 const&amp; t1, T2 const&amp; t2, T3 const&amp; t3, T4 const&amp; t4) {
						std::cout &lt;&lt; t1 &lt;&lt; ' ' &lt;&lt; t2 &lt;&lt; ' ' &lt;&lt; t3 &lt;&lt; ' ' &lt;&lt; t4;
					}
					template &lt;typename T1, typename T2, typename T3, typename T4, typename T5&gt;
					void print(T1 const&amp; t1, T2 const&amp; t2, T3 const&amp; t3, T4 const&amp; t4, T5 const&amp; t5) {
						std::cout &lt;&lt; t1 &lt;&lt; ' ' &lt;&lt; t2 &lt;&lt; ' ' &lt;&lt; t3 &lt;&lt; ' ' &lt;&lt; t4 &lt;&lt; ' ' &lt;&lt; t5;
					}
					</code></pre>
				</section>
				<section>
					<h2>Solution 2 - Variadic Template</h2>

					<pre><code class="cpp" data-trim>
					#include &lt;iostream&gt;
					#include &lt;initializer_list&gt;

					template &lt;typename ... Ts&gt;
					void print(Ts const&amp; ... ts) {
						(void)std::initializer_list&lt;int&gt;{(std::cout &lt;&lt; ts &lt;&lt; ' ', 0)...};
					}
					</code></pre>
				</section>
				<section>
					<h2>Solution 3 - Folding expression</h2>

					<pre><code class="cpp" data-trim>
					template &lt;typename ... Ts&gt;
					void print(Ts const&amp; ... ts) {
						(..., [](auto const&amp; t) { std::cout &lt;&lt; ' ' &lt;&lt; t; }(ts));
					}
					</code></pre>

					<p class="fragment">What about the extra space</p>
				</section>
				<section>
					<h2>Solution 4</h2>

					<pre><code class="cpp" data-trim>
					template &lt;typename T, typename ... Ts&gt;
					void print(T const&amp; t, Ts const&amp; ... ts) {
						std::cout &lt;&lt; t;
						(..., [](auto const&amp; t) { std::cout &lt;&lt; ' ' &lt;&lt; t; }(ts));
					}
					</code></pre>

					<p class="fragment">What about <code>print()</code><p>
				</section>
				<section>
					<h2>Solution 5</h2>

					<pre><code class="cpp" data-trim>
					void print() {}

					template &lt;typename T, typename ... Ts&gt;
					void print(T const&amp; t, Ts const&amp; ... ts) {
						std::cout &lt;&lt; t;
						(..., [](auto const&amp; t) { std::cout &lt;&lt; ' ' &lt;&lt; t; }(ts));
					}
					</code></pre>
				</section>
				<section>
					<h2>Compile time <code>if</code></h2>

					<ul>
						<li>The branch that does not used will never be compiled</li>
					</ul>

					<pre><code class="cpp" data-trim>
					#include &lt;iostream&gt;

					template &lt;typename ... Ts&gt;
					void switch_func(Ts &amp;&amp; ... ts) {
						if constexpr (sizeof...(ts) &gt; 3) {
							std::cout &lt;&lt; "&gt;3";
						} else {
							std::cout &lt;&lt; "&lt;=3";
						}
					}

					int main() {
						switch_func(3, 5.7);
					}
					</code></pre>

					<a href="https://godbolt.org/z/59__CY">code</a>
				</section>
				<section>
					<pre><code class="cpp" data-trim>
					std::string path = "C:\\User\\xmo";
					std::string path = R"(C:\User\xmo)";
					</code></pre>
				</section>
				<section>
					<pre><code class="cpp" data-trim>
					struct S {
						S() = default;
						~S() = default;
						S(S const&amp;) = default;
						S(S&amp;&amp;) = default;
						S&amp; operator(S const&amp;) = delete;
						S&amp; operator(S&amp;&amp;) = delete;
					};
					</code></pre>
				</section>
				<section>
					<h2>Compilers are getting better at optimization</h2>
				</section>
				<section>
					<p>Is this code slow because of jumps</p>

					<pre><code class="cpp" data-trim>
					extern void bar();

					void foo() {
						for (int i=0; i&lt;7; ++i)
							bar();
					}
					</code></pre>
					<a href="https://godbolt.org/z/45gGNa">code</a>
				</section>
				<section>
					<p>Is this code slow because of it jumps one million times?</p>
					<pre><code class="cpp" data-trim>
					#include &lt;cstddef&gt;
					#include &lt;iterator&gt;

					extern int a[1'000'000];

					void foo() {
						for (std::size_t i=0; i&lt;std::size(a); ++i)
							a[i] = 0;
					}
					</code></pre>
					<a href="https://godbolt.org/z/_ruzU_">code</a>
				</section>
				<section>
					<p>What if the the size if not a const at compilation time</p>
					<pre><code class="cpp" data-trim>
					#include &lt;cstddef&gt;

					void foo(int* a, std::size_t size) {
						for (std::size_t i=0; i&lt;size; ++i)
							a[i] = 0;
					}
					</code></pre>
					<a href="https://godbolt.org/z/gvUvgy">code</a>
				</section>
				<section>
					<p>Is standard algorithm efficient enough?</p>
					<pre><code class="cpp" data-trim>
					#include &lt;cstddef&gt;
					#include &lt;algorithm&gt;

					void foo(int* a, std::size_t size) {
						std::generate(a, a+size, []{return 0;});
					}
					</code></pre>
					<a href="https://godbolt.org/z/M5AGnt">code</a>
				</section>
				<section>
					<p>Bjarne Stroustrup says,</p>
					<blockquote>
					Within C++, there is a much smaller and clearer language struggling to get out.
					</blockquote>
					<blockquote class="fragment">
					And no, that smaller and cleaner language is not Java or C#.
					</blockquote>
				</section>
				<section>
					<h2>The Ugly Truth</h2>
					<ul>
						<li class="fragment">The compiler might be trying too hard</li>
						<li class="fragment">Undefined Behavior</li>
					</ul>
					<blockquote>
					<p>If you think it's simple, then you have misunderstood the problem.</p>
					<p>-- Bjarne Stroustrup</p>
					</blockquote>
				</section>
				<section>
					<p>What is the purpose of this function</p>
					<pre><code class="cpp" data-trim>
					bool foo(int n) {
						return (n+1) &gt; n;
					}
					</code></pre>

					<a href="https://godbolt.org/z/uMbkVs">code</a>
				</section>
				<section>
					<pre><code class="cpp" data-trim>
					static void (*FP)();

					extern void impl();

					void set() {
						FP = impl;
					}

					void call() {
						FP();
					}
					</code></pre>

					<a href="https://godbolt.org/z/AAQ6GC">code</a>
				</section>
				<section>
					<pre><code class="cpp" data-trim>
					void foo(int* ptr) {
						int not_used = *ptr;
						if (!ptr)
							return;
						*ptr = 71;
					}
					</code></pre>
					<a href="https://godbolt.org/z/jWaVgj">code</a>
				</section>
				<section>
					<pre><code class="cpp" data-trim>
					#include &lt;memory&gt;

					int main() {
						int* p = (int*)malloc(sizeof(int));
						int* q = (int*)realloc(p, sizeof(int));
						*p = 1;
						*q = 2;
						if (p == q)
							printf("%d == %d\n", *p, *q);
					}
					</code></pre>
					<a href="https://godbolt.org/z/_mEWbZ">code</a>
				</section>
				<section>
					<blockquote>
						There are only two hard things in Computer Science:
						<p class="fragment">1. cache invalidation</p>
						<p class="fragment">2. naming things</p>
						<p class="fragment">3. off-by-one mistake</p>
					</blockquote>
				</section>
				<section>
					<pre><code class="cpp" data-trim>
					extern int data[4];

					bool find(int v) {
						for (int i=0; i&lt;=4; ++i)
							if (data[i] == v)
								return true;
						return false;
					}
					</code></pre>
					<a href="https://godbolt.org/z/cDMjp-">code</a>
				</section>
				<section>
					<pre><code class="cpp" data-trim>
					extern std::array&lt;int, 4&gt; data;

					bool find(int v) {
						for (int i=0; i&lt;=4; ++i)
							if (data[i] == v)
								return true;
						return false;
					}
					</code></pre>
					<a href="https://godbolt.org/z/NX-rg8">code</a>
				</section>
				<section>
					<h2><strong>THE BAD NEWS</strong></h2>
					<blockquote>
						<p>C++ has indeed become too "expert friendly".</p>
						<p>-- Bjarne Stroustrup, 2014</p>
					</blockquote>
				</section>
				<section>
					<pre><code class="cpp" data-trim>
					char foo() {
						return 3["abcdefghijklmnopqrstuvwxyz"];
					}
					</code></pre>
					<pre class="fragment"><code class="cpp" data-trim>
					extern int foo();

					auto (*fp)() -&gt; int{foo};
					</code></pre>
					<pre class="fragment"><code class="cpp" data-trim>
					struct S;

					extern void foo(S(S));
					</code></pre>
				</section>
				<section>
					<pre><code class="cpp" data-trim>
					bool bar() {
						if (false; true)
							return false;
						return true;
					}
					</code></pre>
					<pre class="fragment"><code class="cpp" data-trim>
					bool bar() {
						if (struct S { int i{}; }; true)
							return false;
						return true;
					}
					</code></pre>
				</section>
				<section>
					<pre><code class="cpp" data-trim>
extern void foo();

void (*fp)() =
**********************************
/********************************/
/*      This is C++!            */
/********************************/
**********************************
foo;
					</code></pre>
					<pre class="fragment"><code class="cpp" data-trim>
					extern extern "C++" extern "C" extern "C++" int i;

					extern "C++" extern "C" extern "C++" extern int i;
					</code></pre>
					<p class="fragment">gcc9.2 rejects both</p>
					<p class="fragment">msvc19.22 rejects the first</p>
					<p class="fragment">clang9 thinks both are ok</p>
				</section>
				<section>
					<pre><code class="cpp" data-trim>
					int main() {
						int x = 100;
						x = x---x
						    |x--|
						    x---x;
						return x;
					}
					</code></pre>
					<pre class="fragment"><code class="cpp" data-trim>
					#include &lt;iostream&gt;

					struct S {
						static void foo() { std::cout &lt;&lt; "hello\n"; }
					};
					
					int main() {
						S *s = nullptr;
						s-&gt;foo();
					}
					</code></pre>
				</section>
				<section>
					<h2>The price of writing efficient code</h2>

					<pre><code class="cpp" data-trim>
					class employee {
						std::string name_;
					public:
						template &lt;typename String, typename = std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;String&gt;, std::string&gt;&gt;&gt;
						void set_name(String&amp;&amp; name) noexcept(std::is_nothrow_assignable_v&lt;std::string, String&gt;)
						{ name_ = std::forward&lt;String&gt;(name); }
					};
					</code></pre>

					<blockquote>
						<p class="fragment">This is unteachable...</p>
						<p class="fragment">There are very few people in the world can write it with confidence, I'm not one of them.</p>
						<p class="fragment">-- Bjarne Stroustrup</p>
					</blockquote>
				</section>
				<section>
					<h2>The price of writing correct code</h2>

					<pre><code class="cpp" data-trim>
					#include &lt;iostream&gt;

					int main() {
						int a = -1;
						unsigned b = 1;

						if (a &lt; b) {
							std::cout &lt;&lt; "-1 &lt; 1";
						} else {
							std::cout &lt;&lt; "-1 &gt;= 1";
						}
					}
					</code></pre>
					<ul>
						<li class="fragment"><a href="https://godbolt.org/z/VPxeS7">Don't do math in signed integers</a></li>
						<li class="fragment">Don't do math in unsigned integers</li>
						<li class="fragment">Don't do math in C++</li>
						<li class="fragment">Don't use C++</li>
					</ul>	
				</section>
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				width: 1440,
				slideNumber: true,
				loop: true,
				autoPlayMedia: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>
	</body>
</html>
